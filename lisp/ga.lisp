;;; ga.lisp A simple framework for genenetic algorithms

(require 'poly-str "poly-str")

(defun random-poly-str (total-cardinality)
  (let ((num-vertices (random total-cardinality)))
    (let ((num-edges (random (- total-cardinality num-vertices))))
      (let ((num-faces (- total-cardinality (+ num-edges num-vertices))))
	(let ((ind (make-array (list total-cardinality total-cardinality))))
	  (dotimes (i total-cardinality)
	    (dotimes (j total-cardinality)
	      (setf (aref ind i j) (random 2))))
	  (make-poly-str num-vertices num-edges num-faces ind))))))

(defun random-typed-poly-str (total-cardinality)
  (let ((num-vertices (1+ (random (- total-cardinality 3)))))
    (let ((num-edges (1+ (random (1- (- total-cardinality num-vertices))))))
      (let ((num-faces (- total-cardinality (+ num-edges num-vertices))))
	(let ((ind (make-array (list total-cardinality total-cardinality))))
	  (dotimes (i total-cardinality)
	    (dotimes (j total-cardinality)
	      (setf (aref ind i j) (random 2))))
	  (make-poly-str num-vertices num-edges num-faces ind))))))

(defun random-population (num-individuals)
  (let (pop)
    (dotimes (i num-individuals pop)
      (push (random-poly-str 6) pop))))

(defun random-typed-population (num-individuals)
  (let ((pop nil))
    (dotimes (i num-individuals pop)
      (push (random-typed-poly-str 6) pop))))

(defun crossover-point (poly-str-1 poly-str-2)
  (declare (ignore poly-str-2))
  (let ((n (first (array-dimensions poly-str-1))))
    (cons (random n) (random n))))

(defun meld-matrices (matrix-1 matrix-2 x y)
  (let ((dim (car (array-dimensions matrix-1))))
    (let ((matrix (make-array (list dim dim))))
      (dotimes (i dim matrix)
	(dotimes (j dim)
	  (if (< i x)
	    (if (< j y)
		(setf (aref matrix i j)
		      (aref matrix-1 i j))
		(setf (aref matrix i j)
		      (aref matrix-2 i j)))
	    (if (< j y)
		(setf (aref matrix i j)
		      (aref matrix-2 i j))
		(setf (aref matrix i j)
		      (aref matrix-1 i j)))))))))

(defun combine (poly-str-1 poly-str-2)
  (let ((total-size (cardinality poly-str-1)))
    (let ((flip-1 (random 2))
	  (flip-2 (random 2))
	  (num-vertices)
	  (num-edges)
	  (num-faces))
      (if (= flip-1 0)
	  (setf num-vertices (num-vertices poly-str-1))
	  (setf num-vertices (num-vertices poly-str-2)))
      (if (= flip-2 0)
	  (setf num-edges (num-edges poly-str-1))
	  (setf num-edges (num-edges poly-str-2)))
      (setf num-faces (- total-size (+ num-vertices num-edges)))
      (let ((matrix-1 (incidence-matrix poly-str-1))
	    (matrix-2 (incidence-matrix poly-str-2)))
	(destructuring-bind (cross-x . cross-y)
	    (crossover-point matrix-1 matrix-2)
	  (let ((m (meld-matrices matrix-1 matrix-2 cross-x cross-y)))
	    (make-poly-str num-vertices num-edges num-faces m)))))))

(defun poly-str-fitness (poly-str)
  (let ((n 0))
    (dolist (ax steinitz-rademacher-axioms n)
      (when (true? ax poly-str nil)
	(incf n)))))

(defun typed-poly-str-fitness (poly-str)
  (let ((n 0))
    (dolist (ax steinitz-rademacher-axioms-typed n)
      (when (true? ax poly-str nil)
	(incf n)))))

(defun first-n (lst n)
  (when lst
    (do ((l nil)
	 (i 0 (1+ i))
	 (x (car lst) (car tail))
	 (tail (cdr lst) (cdr tail)))
	((= i n) (reverse l))
      (push x l))))

(defun best-individual (population fitness-function)
  (let ((pop (sort population #'(lambda (ind-1 ind-2)
				  (> (funcall fitness-function ind-1)
				     (funcall fitness-function ind-2))))))
    (first pop)))

(defun best-fitness (population fitness-function)
  (funcall fitness-function (best-individual population fitness-function)))

(defun next-generation (population fitness-function)
  (let ((pop (sort population #'(lambda (ind-1 ind-2)
				  (> (funcall fitness-function ind-1)
				     (funcall fitness-function ind-2))))))
    (let* ((new-gen nil)
	   (num-inds (length pop))
	   (half (/ num-inds 2)))
      (let ((best-half (first-n pop half)))
	(dotimes (i half)
	  (let ((parent-index-1 (random half))
		(parent-index-2 (random half)))
	    (let ((parent-1 (nth parent-index-1 best-half))
		  (parent-2 (nth parent-index-2 best-half)))
	      (push (combine parent-1 parent-2) new-gen))))
	(append new-gen best-half)))))

(defun poly-str-ga (population-size num-generations)
  (let ((pop (random-population population-size)))
    (dotimes (i num-generations pop)
      (setf pop (next-generation pop #'poly-str-fitness)))))

(defun typed-poly-str-ga (population-size num-generations)
  (let ((pop (random-typed-population population-size)))
    (dotimes (i num-generations pop)
      (setf pop (next-generation pop #'typed-poly-str-fitness)))))

;;; ga.lisp ends here