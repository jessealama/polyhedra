;;; ga.lisp A simple framework for genenetic algorithms

(require 'poly-str "poly-str")

(defstruct population
  individuals)

(defun random-poly-str (total-cardinality)
  (let ((num-vertices (random total-cardinality)))
    (let ((num-edges (random (- total-cardinality num-vertices))))
      (let ((num-faces (- total-cardinality (+ num-edges num-vertices))))
	(let ((ind (make-array (list total-cardinality total-cardinality))))
	  (dotimes (i total-cardinality)
	    (dotimes (j 10)
	      (setf (aref ind i j) (random 2))))
	  (make-poly-str num-vertices num-edges num-faces ind))))))

(defun random-population (num-individuals)
  (let (pop)
    (dotimes (i num-individuals pop)
      (push (random-poly-str 10) pop))))

(defun crossover-point (poly-str-1 poly-str-2)
  (declare (ignore poly-str-2))
  (let ((n (first (array-dimensions poly-str-1))))
    (cons (random n) (random n))))

(defun combine (poly-str-1 poly-str-2)
  (let ((total-size (cardinality poly-str-1)))
    (let ((flip-1 (random 2))
	  (flip-2 (random 2))
	  (num-vertices)
	  (num-edges)
	  (num-faces))
      (if (= flip-1 0)
	  (setf num-vertices (num-vertices poly-str-1))
	  (setf num-vertices (num-vertices poly-str-2)))
      (if (= flip-2 0)
	  (setf num-edges (num-edges poly-str-1))
	  (setf num-edges (num-edges poly-str-2)))
      (setf num-faces (- total-size (+ num-vertices num-edges)))
      (let ((matrix-1 (incidence-matrix poly-str-1))
	    (matrix-2 (incidence-matrix poly-str-2)))
	(destructuring-bind (cross-x . cross-y)
	    (crossover-point matrix-1 matrix-2)
	  (let ((matrix (make-array (list total-size total-size))))
	    (dotimes (i total-size)
	      (dotimes (j total-size)
		(if (< i cross-x)
		    (if (< j cross-y)
			(setf (aref matrix i j)
			      (aref matrix-1 i j))
			(setf (aref matrix i j)
			      (aref matrix-2 i j)))
		    (if (< j cross-y)
			(setf (aref matrix i j)
			      (aref matrix-2 i j))
			(setf (aref matrix i j)
			      (aref matrix-1 i j))))))
	    (make-poly-str num-vertices num-edges num-faces matrix)))))))

(defun fitness (poly-str)
  (let ((n 0))
    (dolist (ax steinitz-rademacher-axioms n)
      (when (true? ax poly-str nil)
	(incf n)))))

(defun poly-str-better-than? (poly-str-1 poly-str-2)
  (let ((fit-1 (fitness poly-str-1))
	(fit-2 (fitness poly-str-2)))
    (> fit-1 fit-2)))

(defun first-n (lst n)
  (when lst
    (do ((l nil)
	 (i 0 (1+ i))
	 (x (car lst) (car tail))
	 (tail (cdr lst) (cdr tail)))
	((= i n) (reverse l))
      (push x l))))

(defun next-generation (population)
  (let* ((sorted-pop (sort population #'poly-str-better-than?))
	 (new-gen nil)
	 (num-inds (length population))
	 (half (/ num-inds 2)))
    (let ((best-half (first-n sorted-pop half)))
      (dotimes (i half)
	(let ((parent-index-1 (random half))
	      (parent-index-2 (random half)))
	  (let ((parent-1 (nth parent-index-1 best-half))
		(parent-2 (nth parent-index-2 best-half)))
	    (push (combine parent-1 parent-2) new-gen))))
      (append new-gen best-half))))

(defun ga (num-generations)
  (let ((pop (random-population 4)))
    (dotimes (i num-generations pop)
      (setf pop (next-generation pop)))))

;;; ga.lisp ends here
